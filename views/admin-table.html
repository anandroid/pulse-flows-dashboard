<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Labeling Admin - Pulse Flows</title>
    
    <!-- DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/select/1.7.0/css/select.dataTables.min.css">
    
    <!-- Simple custom styles -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .filters {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .table-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .filter-group {
            display: inline-block;
            margin-right: 20px;
            min-width: 150px;
        }
        
        .filter-group.area-filter {
            min-width: 250px;
        }
        
        .filter-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 14px;
        }
        
        .filter-group select, .filter-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex: 1;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 14px;
            color: #6b7280;
        }
        
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .badge-category {
            background: #f3f4f6;
            color: #374151;
        }
        
        /* Loading overlay styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .loading-content {
            background: white;
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }
        
        .loading-spinner-large {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            margin: 0 auto 20px;
            animation: spin 1s linear infinite;
        }
        
        .loading-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #1f2937;
        }
        
        .loading-message {
            font-size: 16px;
            color: #6b7280;
            margin-bottom: 20px;
        }
        
        .loading-steps {
            text-align: left;
            margin-top: 20px;
        }
        
        .loading-step {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        
        .loading-step.active {
            opacity: 1;
        }
        
        .loading-step.completed {
            opacity: 1;
        }
        
        .loading-step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 14px;
        }
        
        .loading-step.active .loading-step-icon {
            background: #3b82f6;
            color: white;
        }
        
        .loading-step.completed .loading-step-icon {
            background: #10b981;
            color: white;
        }
        
        .loading-step-text {
            flex: 1;
            font-size: 14px;
            color: #4b5563;
        }
        
        .loading-step.active .loading-step-text {
            color: #1f2937;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .thumbnail {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 4px;
        }
        
        .bulk-actions {
            margin-bottom: 15px;
        }
        
        .bulk-actions button {
            margin-right: 10px;
        }
        
        /* DataTable customizations */
        table.dataTable {
            border-collapse: collapse !important;
        }
        
        table.dataTable tbody tr.selected {
            background-color: #dbeafe !important;
        }
        
        .dataTables_wrapper .dataTables_filter {
            float: right;
            margin-bottom: 10px;
        }
        
        .dataTables_wrapper .dataTables_length {
            float: left;
            margin-bottom: 10px;
        }
        
        .scope-select, .quality-input, .relevance-input {
            width: 100px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .filter-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            width: 100%;
            align-items: center;
        }
        
        .filter-chip {
            display: inline-flex;
            align-items: center;
            padding: 3px 6px;
            border-radius: 14px;
            font-size: 11px;
            cursor: pointer;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            justify-content: center;
        }
        
        .filter-chip:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }
        
        .filter-chip.selected {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
        }
        
        .filter-chip .emoji {
            margin-right: 2px;
            font-size: 12px;
        }
        
        .filter-chip .remove {
            margin-left: 4px;
            font-size: 12px;
            color: #6b7280;
            display: none;
        }
        
        .filter-chip.selected .remove {
            display: inline;
            color: #1e40af;
        }
        
        .filter-chip.selected .remove:hover {
            color: #dc2626;
        }
        
        .trending-checkbox {
            width: 16px;
            height: 16px;
        }
        
        .table-loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            .filters {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .filter-group,
            .filter-group.area-filter {
                min-width: auto;
                width: 100%;
                margin-right: 0;
            }
            
            .filter-group select,
            .filter-group input {
                width: 100%;
            }
        }
        
        /* Chat Interface Styles */
        .chat-panel {
            background: white;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .chat-header {
            background: #f8fafc;
            padding: 15px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-toggle {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        
        .chat-toggle:hover {
            background: #2563eb;
        }
        
        .chat-content {
            display: none;
            padding: 20px;
        }
        
        .chat-content.active {
            display: block;
        }
        
        .chat-models {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .model-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            min-width: 200px;
        }
        
        .chat-prompt {
            margin-bottom: 15px;
        }
        
        .prompt-textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }
        
        .chat-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .chat-messages {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            background: #f9fafb;
        }
        
        .chat-message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
        }
        
        .chat-message.user {
            background: #dbeafe;
            margin-left: 20px;
        }
        
        .chat-message.assistant {
            background: #f0f9ff;
            margin-right: 20px;
        }
        
        .chat-message.system {
            background: #f3f4f6;
            margin: 10px;
            border-left: 3px solid #6b7280;
            font-style: italic;
        }
        
        .chat-message .role {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            color: #374151;
        }
        
        .chat-input-area {
            display: flex;
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .evaluation-summary {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .summary-stat {
            text-align: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
        }
        
        .summary-stat .value {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
        }
        
        .summary-stat .label {
            font-size: 12px;
            color: #6b7280;
        }
        
        /* Reasoning indicator tooltip styling */
        .reasoning-indicator {
            position: relative;
            display: inline-block;
            transition: transform 0.2s;
        }
        
        .reasoning-indicator:hover {
            transform: scale(1.2);
        }
        
        /* Better native tooltip styling */
        [title] {
            position: relative;
        }
        
        /* Reasoning details styling */
        details summary::-webkit-details-marker {
            display: none;
        }
        
        details summary::before {
            content: '‚ñ∂';
            display: inline-block;
            margin-right: 5px;
            transition: transform 0.2s;
        }
        
        details[open] summary::before {
            transform: rotate(90deg);
        }
        
        .btn-chat {
            background: #10b981;
            color: white;
        }
        
        .btn-chat:hover {
            background: #059669;
        }
        
        .btn-evaluate {
            background: #8b5cf6;
            color: white;
        }
        
        .btn-evaluate:hover {
            background: #7c3aed;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 style="margin: 0 0 10px 0;">Content Labeling Admin</h1>
            <p style="margin: 0; color: #6b7280;">Label and score content for trending algorithm training</p>
        </div>
        
        <!-- Stats -->
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="total-count">0</div>
                <div class="stat-label">Total Items</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="selected-count" style="color: #3b82f6;">0</div>
                <div class="stat-label">Selected</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="local-count" style="color: #10b981;">0</div>
                <div class="stat-label">Local</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="national-count" style="color: #8b5cf6;">0</div>
                <div class="stat-label">National</div>
            </div>
        </div>
        
        <!-- Filters -->
        <div class="filters">
            <div class="filter-group area-filter">
                <label>Area</label>
                <select id="area-select" style="width: 100%; min-width: 250px;">
                    <option value="">Loading areas...</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Date <small>(optional)</small></label>
                <input type="date" id="date-select" title="Leave empty to load all dates">
            </div>
            <div class="filter-group">
                <label>Category</label>
                <select id="category-filter">
                    <option value="">All Categories</option>
                    <option value="events">Events</option>
                    <option value="deals">Deals</option>
                    <option value="news">News</option>
                    <option value="reels">Reels</option>
                </select>
            </div>
            <button id="load-content" class="btn btn-primary">Load Content</button>
        </div>
        
        <!-- LLM Chat Panel -->
        <div class="chat-panel">
            <div class="chat-header">
                <div>
                    <h3 style="margin: 0; font-size: 16px;">ü§ñ LLM Content Evaluator</h3>
                    <p style="margin: 4px 0 0 0; font-size: 12px; color: #6b7280;">Let AI evaluate and rate your content</p>
                </div>
                <button id="chat-toggle" class="chat-toggle">Open Chat</button>
            </div>
            <div id="chat-content" class="chat-content">
                <!-- Model Selection -->
                <div class="chat-models">
                    <label style="font-weight: 500; color: #374151;">Gemini Model:</label>
                    <select id="model-select" class="model-select">
                        <option value="">Loading models...</option>
                    </select>
                </div>
                
                <!-- Evaluation Mode Toggle -->
                <div style="margin: 15px 0; padding: 15px; background: #f9fafb; border-radius: 6px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151;">Evaluation Mode:</label>
                    <div style="display: flex; gap: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="eval-mode" value="standard" style="margin-right: 5px;">
                            <span>Standard</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="eval-mode" value="agent" checked style="margin-right: 5px;">
                            <span>ü§ñ Agent (Rules + Learning)</span>
                        </label>
                    </div>
                    <small style="color: #6b7280; display: block; margin-top: 8px;">
                        Agent mode: Uses rules engine first, then enhanced corrections with pattern matching
                    </small>
                </div>
                
                <!-- Evaluation Prompt -->
                <div class="chat-prompt">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151;">User Message (the system will use the labeling guide automatically):</label>
                    <textarea id="prompt-textarea" class="prompt-textarea" placeholder="Enter your evaluation instructions...">Please evaluate all content and provide ratings based on the labeling guide.</textarea>
                </div>
                
                <!-- Action Buttons -->
                <div class="chat-actions">
                    <button id="evaluate-btn" class="btn btn-evaluate">üß† Evaluate All Content</button>
                    <button id="reload-prompt-btn" class="btn btn-secondary">üîÑ Reload Default Prompt</button>
                    <button id="learn-rules-btn" class="btn btn-secondary" style="background: #8b5cf6;">üìö Learn from Corrections</button>
                </div>
                
                <!-- Evaluation Summary -->
                <div id="evaluation-summary" class="evaluation-summary" style="display: none;">
                    <h4 style="margin: 0 0 10px 0; color: #1f2937;">Evaluation Summary</h4>
                    <p id="summary-message" style="margin: 0 0 10px 0; color: #374151;"></p>
                    <div class="summary-stats">
                        <div class="summary-stat">
                            <div id="summary-local" class="value">0</div>
                            <div class="label">Local</div>
                        </div>
                        <div class="summary-stat">
                            <div id="summary-national" class="value">0</div>
                            <div class="label">National</div>
                        </div>
                        <div class="summary-stat">
                            <div id="summary-hyperlocal" class="value">0</div>
                            <div class="label">Hyperlocal</div>
                        </div>
                        <div class="summary-stat">
                            <div id="summary-quality" class="value">0</div>
                            <div class="label">Avg Quality</div>
                        </div>
                        <div class="summary-stat">
                            <div id="summary-relevance" class="value">0</div>
                            <div class="label">Avg Relevance</div>
                        </div>
                        <div class="summary-stat">
                            <div id="summary-trending" class="value">0</div>
                            <div class="label">Trending</div>
                        </div>
                    </div>
                    
                    <!-- Reasoning samples -->
                    <details id="reasoning-details" style="margin-top: 15px;">
                        <summary style="cursor: pointer; font-weight: 500; color: #374151;">üí≠ View Sample Reasoning</summary>
                        <div id="reasoning-samples" style="margin-top: 10px; max-height: 200px; overflow-y: auto; font-size: 13px; color: #6b7280;">
                            <!-- Reasoning samples will be added here -->
                        </div>
                    </details>
                </div>
                
                <!-- Chat Messages -->
                <div id="chat-messages" class="chat-messages" style="display: none;">
                    <div class="chat-message assistant">
                        <div class="role">Assistant</div>
                        <div>Hi! I'm ready to help evaluate your content. Click "Evaluate All Content" to get started, or ask me any questions about content rating.</div>
                    </div>
                </div>
                
                <!-- Chat Input -->
                <div id="chat-input-area" class="chat-input-area" style="display: none;">
                    <input type="text" id="chat-input" class="chat-input" placeholder="Ask about content evaluation or request modifications..." />
                    <button id="chat-send-btn" class="btn btn-chat">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Table Container -->
        <div class="table-container">
            <div class="bulk-actions">
                <button class="btn btn-secondary bulk-action" data-action="mark-local">Mark Selected as Local</button>
                <button class="btn btn-secondary bulk-action" data-action="mark-national">Mark Selected as National</button>
                <button class="btn btn-secondary bulk-action" data-action="refer-chat" style="background: #6366f1; color: white;">üìù Refer Selected in Chat</button>
                <button id="submit-labels" class="btn btn-success" style="float: right;" disabled>
                    Submit Labels for <span id="submit-area">Area</span>
                </button>
            </div>
            
            <table id="content-table" class="display" style="width:100%">
                <thead>
                    <tr>
                        <th></th>
                        <th>Image</th>
                        <th>Title</th>
                        <th>Source</th>
                        <th>Category</th>
                        <th>Date</th>
                        <th>Scope</th>
                        <th>Quality</th>
                        <th>Relevance</th>
                        <th>Trending</th>
                        <th>Filters</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Table rows will be populated here -->
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner-large"></div>
            <h2 class="loading-title">Loading Content</h2>
            <p class="loading-message">Please wait while we process your request...</p>
            <div class="loading-steps" id="loading-steps">
                <div class="loading-step" data-step="fetch">
                    <div class="loading-step-icon">1</div>
                    <div class="loading-step-text">Fetching content from server</div>
                </div>
                <div class="loading-step" data-step="process">
                    <div class="loading-step-icon">2</div>
                    <div class="loading-step-text">Processing data</div>
                </div>
                <div class="loading-step" data-step="render">
                    <div class="loading-step-icon">3</div>
                    <div class="loading-step-text">Rendering table</div>
                </div>
                <div class="loading-step" data-step="complete">
                    <div class="loading-step-icon">‚úì</div>
                    <div class="loading-step-text">Complete</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/select/1.7.0/js/dataTables.select.min.js"></script>
    <script>
        // Content Labeling Admin - Table Version
        class ContentLabelingTable {
            constructor() {
                this.table = null;
                this.contentData = [];
                this.labels = new Map();
                this.currentArea = '';
                this.currentAreaName = '';
                this.chatModels = [];
                this.conversationHistory = [];
                this.currentEvaluation = null;
                this.originalEvaluations = new Map(); // Track original AI evaluations
                this.areaFilters = []; // Store area-specific filters
                this.filterAssignments = new Map(); // Track filter assignments per content
                
                this.initializeEventListeners();
                this.loadAreas();
                this.setDefaultDate();
                this.loadChatModels();
            }
            
            // Loading overlay methods
            showLoadingOverlay(title, message, steps = null) {
                const overlay = $('#loading-overlay');
                overlay.find('.loading-title').text(title);
                overlay.find('.loading-message').text(message);
                
                if (steps) {
                    const stepsContainer = $('#loading-steps');
                    stepsContainer.empty();
                    steps.forEach((step, index) => {
                        const stepHtml = `
                            <div class="loading-step" data-step="${step.id}">
                                <div class="loading-step-icon">${index + 1}</div>
                                <div class="loading-step-text">${step.text}</div>
                            </div>
                        `;
                        stepsContainer.append(stepHtml);
                    });
                    stepsContainer.show();
                } else {
                    $('#loading-steps').hide();
                }
                
                overlay.css('display', 'flex');
            }
            
            updateLoadingStep(stepId, status = 'active', customText = null) {
                const step = $(`.loading-step[data-step="${stepId}"]`);
                
                // Remove all status classes
                step.removeClass('active completed');
                
                if (status === 'completed') {
                    step.addClass('completed');
                    step.find('.loading-step-icon').text('‚úì');
                } else if (status === 'active') {
                    step.addClass('active');
                }
                
                if (customText) {
                    step.find('.loading-step-text').text(customText);
                }
            }
            
            hideLoadingOverlay() {
                $('#loading-overlay').fadeOut(200);
            }

            initializeEventListeners() {
                $('#load-content').on('click', () => this.loadContent());
                $('#area-select').on('change', (e) => {
                    this.currentArea = e.target.value;
                    // Get the selected option text for display name
                    const selectedOption = e.target.options[e.target.selectedIndex];
                    this.currentAreaName = selectedOption.text.split(',')[0].trim(); // Get just the city name
                    $('#submit-area').text(this.currentAreaName || 'Area');
                });

                $('.bulk-action').on('click', (e) => {
                    const action = $(e.target).data('action');
                    this.handleBulkAction(action);
                });

                $('#submit-labels').on('click', () => this.submitLabels());
                
                // Chat interface event listeners
                $('#chat-toggle').on('click', () => this.toggleChat());
                $('#evaluate-btn').on('click', () => this.evaluateContent());
                $('#reload-prompt-btn').on('click', () => this.loadDefaultPrompt());
                $('#learn-rules-btn').on('click', () => this.learnFromCorrections());
                $('#chat-send-btn').on('click', () => this.sendChatMessage());
                $('#chat-input').on('keypress', (e) => {
                    if (e.which === 13) this.sendChatMessage();
                });
            }

            async loadAreas() {
                const select = $('#area-select');
                select.empty().append('<option value="">Loading areas...</option>');
                select.prop('disabled', true);
                
                try {
                    const response = await fetch('/api/flows/areas');
                    const data = await response.json();
                    
                    select.empty().append('<option value="">Select an area...</option>');
                    
                    data.areas.forEach(area => {
                        select.append(`<option value="${area.id}">${area.name}, ${area.region}</option>`);
                    });
                    
                    select.prop('disabled', false);
                } catch (error) {
                    console.error('Failed to load areas:', error);
                    select.empty().append('<option value="">Error loading areas</option>');
                }
            }

            setDefaultDate() {
                // Leave date empty to load all dates by default
                $('#date-select').val('');
            }

            async loadAreaFilters(area) {
                try {
                    const response = await fetch(`/api/flows/filters/${area}`);
                    const data = await response.json();
                    
                    if (data.success && data.filters) {
                        // Extract filter items from numbered keys
                        this.areaFilters = [];
                        Object.keys(data.filters).forEach(key => {
                            if (!isNaN(parseInt(key))) {
                                const filter = data.filters[key];
                                if (filter && typeof filter === 'object' && filter.id) {
                                    this.areaFilters.push(filter);
                                }
                            }
                        });
                        console.log(`[Filters] Loaded ${this.areaFilters.length} filters for ${area}`);
                    }
                } catch (error) {
                    console.error('Failed to load area filters:', error);
                    this.areaFilters = [];
                }
            }

            async loadContent() {
                const area = $('#area-select').val();
                const date = $('#date-select').val();
                const category = $('#category-filter').val();

                if (!area) {
                    alert('Please select an area');
                    return;
                }

                // Show loading overlay with steps
                this.showLoadingOverlay(
                    'Loading Content',
                    `Fetching ${this.currentAreaName} content...`,
                    [
                        { id: 'connect', text: 'Connecting to server' },
                        { id: 'fetch', text: 'Fetching content from database' },
                        { id: 'process', text: 'Processing content items' },
                        { id: 'render', text: 'Rendering data table' },
                        { id: 'complete', text: 'Complete' }
                    ]
                );

                try {
                    this.updateLoadingStep('connect', 'active');
                    
                    const params = new URLSearchParams({ area });
                    if (date) params.append('date', date);
                    if (category) params.append('category', category);

                    this.updateLoadingStep('connect', 'completed');
                    this.updateLoadingStep('fetch', 'active', 'Retrieving content from Firestore...');

                    const response = await fetch(`/api/flows/admin/content?${params}`);
                    const data = await response.json();

                    if (data.success) {
                        this.updateLoadingStep('fetch', 'completed', `Found ${data.count} items`);
                        this.updateLoadingStep('process', 'active', 'Processing content data...');
                        
                        this.contentData = data.content;
                        
                        // Load area filters
                        await this.loadAreaFilters(area);
                        
                        // Load existing filter assignments from content labels
                        this.filterAssignments.clear();
                        this.contentData.forEach(item => {
                            if (item.labels && item.labels.filters) {
                                this.filterAssignments.set(item.id, item.labels.filters);
                            }
                        });
                        
                        this.updateLoadingStep('process', 'completed');
                        this.updateLoadingStep('render', 'active', 'Building data table...');
                        
                        await this.renderTable();
                        
                        this.updateLoadingStep('render', 'completed');
                        this.updateLoadingStep('complete', 'completed', 'All done!');
                        
                        this.updateStats();
                        
                        // Show what was loaded
                        const loadMessage = date 
                            ? `Loaded ${data.count} items from ${this.currentAreaName} for ${new Date(date).toLocaleDateString()}`
                            : `Loaded ${data.count} items from ${this.currentAreaName} (all dates)`;
                        console.log('[Content]', loadMessage);
                        
                        // Update default prompt with area name
                        if (this.currentAreaName) {
                            $('#prompt-textarea').val(`Please evaluate all ${this.currentAreaName} content and provide ratings (scope, quality, relevance, trending) and select appropriate filters based on the labeling guide.`);
                        }
                        
                        // Hide overlay after a short delay to show completion
                        setTimeout(() => {
                            this.hideLoadingOverlay();
                        }, 500);
                    } else {
                        this.hideLoadingOverlay();
                        alert('Failed to load content: ' + data.error);
                    }
                } catch (error) {
                    console.error('Failed to load content:', error);
                    this.hideLoadingOverlay();
                    alert('Failed to load content: ' + error.message);
                }
            }

            async renderTable() {
                // Destroy existing table if it exists
                if (this.table) {
                    this.table.destroy();
                    $('#content-table tbody').empty();
                }

                // Prepare data for DataTable
                const tableData = this.contentData.map(item => {
                    const labels = this.labels.get(item.id) || item.labels || {};
                    const filters = this.filterAssignments.get(item.id) || [];
                    
                    return [
                        '', // Checkbox column
                        item.image_url || item.thumbnail_url || '',
                        item.title,
                        item.source,
                        item.category,
                        new Date(item.timestamp).toLocaleString(),
                        labels.scope || '',
                        labels.quality || '',
                        labels.relevance || '',
                        labels.trending || false,
                        filters, // Filter assignments
                        item // Store the full item data
                    ];
                });

                // Initialize DataTable
                this.table = $('#content-table').DataTable({
                    data: tableData,
                    pageLength: 50,
                    select: {
                        style: 'multi',
                        selector: 'td:first-child'
                    },
                    order: [[5, 'desc']], // Sort by date descending
                    columns: [
                        {
                            data: null,
                            defaultContent: '',
                            className: 'select-checkbox',
                            orderable: false,
                            width: '30px'
                        },
                        {
                            data: 1,
                            render: function(data) {
                                if (data) {
                                    return `<img src="${data}" class="thumbnail" onerror="this.style.display='none'">`;
                                }
                                return '<div style="width:60px;height:60px;background:#f3f4f6;border-radius:4px;"></div>';
                            },
                            orderable: false,
                            width: '80px'
                        },
                        {
                            data: 2,
                            render: function(data, type, row) {
                                const item = row[11]; // Updated index
                                return `<div style="max-width: 300px;">
                                    <div style="font-weight: 500;">${data}</div>
                                    ${item.description ? `<div style="font-size: 12px; color: #6b7280; margin-top: 4px;">${item.description.substring(0, 100)}...</div>` : ''}
                                </div>`;
                            }
                        },
                        { data: 3 },
                        {
                            data: 4,
                            render: function(data) {
                                return `<span class="badge badge-category">${data}</span>`;
                            }
                        },
                        {
                            data: 5,
                            render: function(data) {
                                return new Date(data).toLocaleDateString();
                            }
                        },
                        {
                            data: 6,
                            render: function(data, type, row) {
                                const item = row[11]; // Updated index
                                const selected = data || '';
                                return `<select class="scope-select" data-id="${item.id}">
                                    <option value="">-</option>
                                    <option value="local" ${selected === 'local' ? 'selected' : ''}>Local</option>
                                    <option value="national" ${selected === 'national' ? 'selected' : ''}>National</option>
                                    <option value="hyperlocal" ${selected === 'hyperlocal' ? 'selected' : ''}>Hyper-local</option>
                                </select>`;
                            }
                        },
                        {
                            data: 7,
                            render: function(data, type, row) {
                                const item = row[11]; // Updated index
                                return `<input type="number" class="quality-input" data-id="${item.id}" 
                                        value="${data || ''}" min="1" max="10" placeholder="1-10">`;
                            }
                        },
                        {
                            data: 8,
                            render: function(data, type, row) {
                                const item = row[11]; // Updated index
                                return `<input type="number" class="relevance-input" data-id="${item.id}" 
                                        value="${data || ''}" min="1" max="10" placeholder="1-10">`;
                            }
                        },
                        {
                            data: 9,
                            render: function(data, type, row) {
                                const item = row[11]; // Updated index
                                return `<input type="checkbox" class="trending-checkbox" data-id="${item.id}" 
                                        ${data ? 'checked' : ''}>`;
                            }
                        },
                        {
                            data: 10,
                            width: '480px',
                            render: (data, type, row) => {
                                const item = row[11]; // item is now at index 11
                                const selectedFilters = data || [];
                                
                                // Create filter chips container
                                const filterChips = this.areaFilters.map(filter => {
                                    const isSelected = selectedFilters.includes(filter.id);
                                    const selectedClass = isSelected ? 'selected' : '';
                                    return `
                                        <div class="filter-chip ${selectedClass}" 
                                             data-filter-id="${filter.id}" 
                                             data-content-id="${item.id}">
                                            <span class="emoji">${filter.emoji}</span>
                                            <span>${filter.label}</span>
                                            <span class="remove">√ó</span>
                                        </div>
                                    `;
                                }).join('');
                                
                                return `<div class="filter-container" data-id="${item.id}">${filterChips}</div>`;
                            }
                        }
                    ],
                    drawCallback: () => {
                        // Re-attach event listeners after table redraw
                        this.attachInputListeners();
                    }
                });

                // Handle row selection events
                this.table.on('select deselect', () => {
                    this.updateStats();
                });
                
                // Small delay to ensure table is fully rendered
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            attachInputListeners() {
                // Scope select
                $('.scope-select').off('change').on('change', (e) => {
                    const id = $(e.target).data('id');
                    const value = $(e.target).val();
                    this.updateLabel(id, 'scope', value);
                });

                // Quality input
                $('.quality-input').off('change').on('change', (e) => {
                    const id = $(e.target).data('id');
                    const value = $(e.target).val();
                    this.updateLabel(id, 'quality', value ? parseInt(value) : null);
                });

                // Relevance input
                $('.relevance-input').off('change').on('change', (e) => {
                    const id = $(e.target).data('id');
                    const value = $(e.target).val();
                    this.updateLabel(id, 'relevance', value ? parseInt(value) : null);
                });

                // Trending checkbox
                $('.trending-checkbox').off('change').on('change', (e) => {
                    const id = $(e.target).data('id');
                    const value = $(e.target).is(':checked');
                    this.updateLabel(id, 'trending', value);
                });
                
                // Teaching buttons - use event delegation for dynamically added buttons
                $(document).off('click', '.teach-button').on('click', '.teach-button', (e) => {
                    const id = $(e.target).data('id');
                    this.openTeachingDialog(id);
                });
                
                // Filter chip clicks - use event delegation
                $(document).off('click', '.filter-chip').on('click', '.filter-chip', (e) => {
                    e.stopPropagation();
                    const chip = $(e.currentTarget);
                    const filterId = chip.data('filter-id');
                    const contentId = chip.data('content-id');
                    
                    // Get current filters for this content
                    const currentFilters = this.filterAssignments.get(contentId) || [];
                    
                    if (chip.hasClass('selected')) {
                        // Remove filter
                        const newFilters = currentFilters.filter(f => f !== filterId);
                        this.updateFilters(contentId, newFilters);
                        chip.removeClass('selected');
                    } else {
                        // Add filter
                        const newFilters = [...currentFilters, filterId];
                        this.updateFilters(contentId, newFilters);
                        chip.addClass('selected');
                    }
                });
            }

            updateFilters(contentId, filters) {
                this.filterAssignments.set(contentId, filters);
                console.log(`[Filters] Updated filters for ${contentId}:`, filters);
                this.updateStats();
            }

            updateLabel(contentId, labelType, value) {
                if (!this.labels.has(contentId)) {
                    this.labels.set(contentId, {});
                }

                const labels = this.labels.get(contentId);
                if (value === '' || value === null || value === false) {
                    delete labels[labelType];
                } else {
                    labels[labelType] = value;
                }

                // Check if we should show the teach button
                const original = this.originalEvaluations.get(contentId);
                if (original && this.hasChanged(original, labels)) {
                    // Add teach button if it doesn't exist
                    const row = this.table.rows((idx, data) => data[10].id === contentId).nodes().to$();
                    if (row.length > 0 && row.find('.teach-button').length === 0) {
                        const teachHtml = `<button class="teach-button" data-id="${contentId}" style="margin-left: 5px; padding: 2px 6px; font-size: 11px; background: #fbbf24; color: #78350f; border: none; border-radius: 3px; cursor: pointer;" title="Teach why you made this correction">üéì</button>`;
                        row.find('td:nth-child(3) > div').append(teachHtml);
                    }
                }

                this.updateStats();
            }

            handleBulkAction(action) {
                const selectedRows = this.table.rows({ selected: true }).data();
                
                if (action === 'refer-chat') {
                    // Handle refer to chat action
                    const selectedItems = [];
                    selectedRows.each((row) => {
                        const item = row[11]; // Updated index due to filters column
                        selectedItems.push(item); // Push the full item
                    });
                    
                    if (selectedItems.length > 0) {
                        // Open chat if not already open
                        if (!$('.chat-container').hasClass('chat-open')) {
                            this.toggleChat();
                        }
                        
                        // Store selected items for targeted evaluation
                        this.selectedForEvaluation = selectedItems.map(item => item.id);
                        
                        // Directly evaluate the selected items
                        this.addChatMessage('user', `Evaluating ${selectedItems.length} selected items...`);
                        
                        // Use the default prompt if prompt is empty
                        if (!$('#prompt-textarea').val().trim()) {
                            this.loadDefaultPrompt();
                        }
                        
                        // Evaluate only the selected items
                        this.evaluateContent(selectedItems, false);
                    }
                    return;
                }
                
                selectedRows.each((row) => {
                    const item = row[11]; // Updated index due to filters column
                    
                    switch (action) {
                        case 'mark-local':
                            this.updateLabel(item.id, 'scope', 'local');
                            // Update the select in the table
                            $(`.scope-select[data-id="${item.id}"]`).val('local');
                            break;
                            
                        case 'mark-national':
                            this.updateLabel(item.id, 'scope', 'national');
                            // Update the select in the table
                            $(`.scope-select[data-id="${item.id}"]`).val('national');
                            break;
                    }
                });
                
                this.updateStats();
            }

            updateStats() {
                const totalCount = this.contentData.length;
                const selectedCount = this.table ? this.table.rows({ selected: true }).count() : 0;
                
                let localCount = 0;
                let nationalCount = 0;
                let labeledCount = 0;
                let itemsWithFilters = 0;

                this.labels.forEach((labels, contentId) => {
                    if (Object.keys(labels).length > 0) {
                        labeledCount++;
                        if (labels.scope === 'local') localCount++;
                        if (labels.scope === 'national') nationalCount++;
                    }
                });
                
                // Count items with filters
                this.filterAssignments.forEach((filters) => {
                    if (filters && filters.length > 0) {
                        itemsWithFilters++;
                    }
                });

                $('#total-count').text(totalCount);
                $('#selected-count').text(selectedCount);
                $('#local-count').text(localCount);
                $('#national-count').text(nationalCount);

                // Enable/disable submit button if items are labeled or have filters
                const hasLabelsOrFilters = labeledCount > 0 || itemsWithFilters > 0;
                $('#submit-labels').prop('disabled', !hasLabelsOrFilters);
            }

            async submitLabels() {
                const labeledItems = [];
                const corrections = [];
                
                // Process items with labels
                this.labels.forEach((labels, contentId) => {
                    if (Object.keys(labels).length > 0) {
                        const item = {
                            contentId: contentId,
                            labels: labels
                        };
                        
                        // Add filter assignments if any
                        const filters = this.filterAssignments.get(contentId);
                        if (filters && filters.length > 0) {
                            item.labels.filters = filters;
                        }
                        
                        labeledItems.push(item);
                        
                        // Check if this is a correction from AI evaluation
                        const original = this.originalEvaluations.get(contentId);
                        if (original && this.hasChanged(original, labels)) {
                            corrections.push({
                                contentId: contentId,
                                originalRating: original,
                                correctedRating: labels
                            });
                        }
                    }
                });
                
                // Also process items that only have filters (no other labels)
                this.filterAssignments.forEach((filters, contentId) => {
                    if (filters && filters.length > 0 && !this.labels.has(contentId)) {
                        labeledItems.push({
                            contentId: contentId,
                            labels: { filters: filters }
                        });
                    }
                });

                if (labeledItems.length === 0) {
                    alert('No items have been labeled or filtered');
                    return;
                }

                if (!confirm(`Submit ${labeledItems.length} labeled items?`)) {
                    return;
                }

                // Show loading overlay for submission
                const steps = [
                    { id: 'prepare', text: `Preparing ${labeledItems.length} labels for submission` },
                    { id: 'submit', text: 'Submitting labels to server' },
                    { id: 'save', text: 'Saving to database' }
                ];
                
                if (corrections.length > 0) {
                    steps.push(
                        { id: 'corrections', text: `Processing ${corrections.length} corrections` },
                        { id: 'learning', text: 'Learning from corrections' }
                    );
                }
                
                steps.push({ id: 'complete', text: 'Complete' });
                
                this.showLoadingOverlay(
                    'Submitting Labels',
                    `Submitting ${labeledItems.length} labels for ${this.currentAreaName}...`,
                    steps
                );

                try {
                    this.updateLoadingStep('prepare', 'active');
                    
                    // Small delay to show preparation
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    this.updateLoadingStep('prepare', 'completed');
                    this.updateLoadingStep('submit', 'active', 'Sending data to server...');
                    
                    const response = await fetch('/api/flows/admin/labels', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            area: this.currentArea,
                            labels: labeledItems,
                            timestamp: new Date().toISOString(),
                            corrections: corrections
                        })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        this.updateLoadingStep('submit', 'completed');
                        this.updateLoadingStep('save', 'active', 'Writing to Firestore...');
                        
                        // Small delay to show saving
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        this.updateLoadingStep('save', 'completed', `Saved ${data.saved} labels`);
                        
                        // If we had corrections, process them in parallel (non-blocking)
                        if (corrections.length > 0) {
                            this.updateLoadingStep('corrections', 'active', 'Storing corrections...');
                            this.addChatMessage('system', `üìö Processing ${corrections.length} corrections...`);
                            
                            // Store corrections and learn in parallel
                            try {
                                await this.storeCorrections(corrections);
                                this.updateLoadingStep('corrections', 'completed');
                                
                                this.updateLoadingStep('learning', 'active', 'Analyzing patterns...');
                                await new Promise(resolve => setTimeout(resolve, 500));
                                
                                const learningResult = await this.learnFromCorrections(true);
                                this.updateLoadingStep('learning', 'completed', 'Learning complete');
                                
                                this.addChatMessage('system', '‚úÖ Corrections processed and learning complete!');
                            } catch (error) {
                                console.error('Error processing corrections:', error);
                                this.updateLoadingStep('learning', 'completed', 'Learning skipped');
                                this.addChatMessage('system', '‚ö†Ô∏è Some corrections may not have been processed.');
                            }
                        }
                        
                        this.updateLoadingStep('complete', 'completed', 'All done!');
                        
                        // Show completion for a moment
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        this.hideLoadingOverlay();
                        
                        // Clear labels and reload
                        this.labels.clear();
                        this.originalEvaluations.clear();
                        this.loadContent(); // Reload content
                    } else {
                        this.hideLoadingOverlay();
                        alert('Failed to submit labels: ' + data.error);
                    }
                } catch (error) {
                    console.error('Failed to submit labels:', error);
                    this.hideLoadingOverlay();
                    alert('Failed to submit labels: ' + error.message);
                }
            }

            hasChanged(original, current) {
                // Check basic properties
                const basicChanged = original.scope !== current.scope ||
                       original.quality !== current.quality ||
                       original.relevance !== current.relevance ||
                       original.trending !== current.trending;
                
                // Check filters
                const originalFilters = original.filters || [];
                const currentFilters = current.filters || [];
                const filtersChanged = originalFilters.length !== currentFilters.length ||
                       !originalFilters.every(f => currentFilters.includes(f));
                
                return basicChanged || filtersChanged;
            }
            
            async storeCorrections(corrections) {
                // Store each correction with content snapshot
                for (const correction of corrections) {
                    const content = this.contentData.find(c => c.id === correction.contentId);
                    if (!content) continue;
                    
                    try {
                        await fetch('/api/flows/admin/corrections', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contentId: correction.contentId,
                                contentSnapshot: {
                                    title: content.title,
                                    description: content.description || '',
                                    source: content.source,
                                    category: content.category,
                                    original_data: content
                                },
                                area: this.currentArea,
                                originalRating: correction.originalRating,
                                correctedRating: correction.correctedRating,
                                correctionReason: 'Manual correction during labeling'
                            })
                        });
                    } catch (error) {
                        console.error('Failed to store correction:', error);
                    }
                }
            }
            
            async openTeachingDialog(contentId) {
                console.log('[Teaching] Opening dialog for:', contentId);
                
                const content = this.contentData.find(c => c.id === contentId);
                const original = this.originalEvaluations.get(contentId);
                const current = this.labels.get(contentId);
                
                console.log('[Teaching] Content:', content);
                console.log('[Teaching] Original:', original);
                console.log('[Teaching] Current:', current);
                
                if (!content) {
                    alert('Content not found. Please refresh the page.');
                    return;
                }
                
                if (!original) {
                    alert('No original evaluation found. The teaching feature only works for AI-evaluated items that you have modified.');
                    return;
                }
                
                if (!current) {
                    alert('No current labels found. Please modify the ratings first.');
                    return;
                }
                
                // Create a simple dialog for teaching
                const reason = prompt(
                    `Why did you change the evaluation for:\n\n"${content.title}"\n\n` +
                    `From: ${original.scope}, Q:${original.quality}, R:${original.relevance}\n` +
                    `To: ${current.scope}, Q:${current.quality}, R:${current.relevance}\n\n` +
                    `Explain your reasoning (this helps the AI learn):`
                );
                
                if (reason && reason.trim()) {
                    try {
                        // Store the correction with the teaching reason
                        const response = await fetch('/api/flows/admin/corrections', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contentId,
                                contentSnapshot: {
                                    title: content.title,
                                    description: content.description || '',
                                    source: content.source,
                                    category: content.category,
                                    original_data: content
                                },
                                area: this.currentArea,
                                originalRating: original,
                                correctedRating: current,
                                correctionReason: reason.trim()
                            })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            // Update button to show it's been taught
                            $(`.teach-button[data-id="${contentId}"]`)
                                .text('‚úì')
                                .css('background', '#10b981')
                                .prop('disabled', true);
                        }
                    } catch (error) {
                        console.error('Failed to store teaching:', error);
                    }
                }
            }

            // === CHAT INTERFACE METHODS ===

            async loadChatModels() {
                try {
                    const response = await fetch('/api/flows/admin/chat/models');
                    const data = await response.json();
                    
                    if (data.success) {
                        this.chatModels = data.models;
                        const select = $('#model-select');
                        select.empty();
                        
                        data.models.forEach(model => {
                            const option = $('<option></option>');
                            option.val(model.id);
                            option.text(`${model.name} - ${model.description}`);
                            if (model.id === 'gemini-1.5-pro-002') option.prop('selected', true);
                            select.append(option);
                        });
                    }
                } catch (error) {
                    console.error('Failed to load chat models:', error);
                }
            }

            toggleChat() {
                const content = $('#chat-content');
                const button = $('#chat-toggle');
                
                if (content.hasClass('active')) {
                    content.removeClass('active');
                    button.text('Open Chat');
                } else {
                    content.addClass('active');
                    button.text('Close Chat');
                    
                    // Load default prompt if needed
                    if (!$('#prompt-textarea').val() && this.currentArea) {
                        this.loadDefaultPrompt();
                    }
                }
            }

            async loadDefaultPrompt() {
                // Default prompt is now used as system instruction
                // User message remains simple and focused
                const areaName = this.currentAreaName || 'this area';
                $('#prompt-textarea').val(`Please evaluate all ${areaName} content and provide ratings (scope, quality, relevance, trending) and select appropriate filters based on the labeling guide.`);
            }
            
            async learnFromCorrections(isBackground = false) {
                const button = $('#learn-rules-btn');
                const originalText = button.html();
                
                // Only show UI updates if not background
                if (!isBackground) {
                    button.html(`<span class="loading-spinner"></span>Learning...`);
                    button.prop('disabled', true);
                }
                
                try {
                    const response = await fetch('/api/flows/admin/corrections/learn', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Only show messages if not background (they're shown by the submit handler)
                        if (!isBackground) {
                            this.addChatMessage('system', `‚úÖ ${data.message}`);
                            
                            // Show details if available
                            if (data.result) {
                                this.addChatMessage('system', 
                                    `Found ${data.result.patternsFound} patterns, created ${data.result.rulesCreated} rules.`
                                );
                            }
                            
                            // If in agent mode, notify that new rules will be used
                            const evalMode = $('input[name="eval-mode"]:checked').val();
                            if (evalMode === 'agent') {
                                this.addChatMessage('system', 
                                    'ü§ñ Agent mode will now use the newly created rules in future evaluations.'
                                );
                            }
                        }
                        
                        return data; // Return data for background processing
                    } else {
                        if (!isBackground) {
                            alert('Failed to learn from corrections: ' + data.error);
                        }
                        throw new Error(data.error);
                    }
                } catch (error) {
                    console.error('Learning failed:', error);
                    if (!isBackground) {
                        alert('Failed to learn from corrections');
                    }
                    throw error;
                } finally {
                    if (!isBackground) {
                        button.html(originalText);
                        button.prop('disabled', false);
                    }
                }
            }

            async evaluateContent(contentToEvaluate = null, isAutoRetry = false) {
                if (!this.currentArea || this.contentData.length === 0) {
                    alert('Please load content first');
                    return;
                }

                const prompt = $('#prompt-textarea').val();
                const model = $('#model-select').val();

                if (!prompt.trim()) {
                    alert('Please enter an evaluation prompt');
                    return;
                }

                // Use provided content or all content
                const evaluationContent = contentToEvaluate || this.contentData;
                const evalMode = $('input[name="eval-mode"]:checked').val();
                
                // Process in batches of 15 items
                const BATCH_SIZE = 15;
                if (evaluationContent.length > BATCH_SIZE) {
                    return this.evaluateContentInBatches(evaluationContent, BATCH_SIZE);
                }
                
                // Show loading overlay for evaluation
                const steps = [
                    { id: 'prepare', text: `Preparing ${evaluationContent.length} items for evaluation` },
                    { id: 'send', text: 'Sending to AI model' },
                    { id: 'process', text: `Processing with ${model}` },
                    { id: 'apply', text: 'Applying ratings to UI' }
                ];
                
                if (evalMode === 'agent') {
                    steps.splice(2, 0, 
                        { id: 'rules', text: 'Checking rules engine' },
                        { id: 'corrections', text: 'Applying learned corrections' }
                    );
                }
                
                steps.push({ id: 'complete', text: 'Complete' });
                
                const title = isAutoRetry ? 'Re-evaluating Content' : 'Evaluating Content';
                const expectedTime = Math.max(30, evaluationContent.length * 3);
                const message = isAutoRetry 
                    ? `Re-evaluating ${evaluationContent.length} unevaluated items... (up to ${expectedTime} seconds)`
                    : `Evaluating ${evaluationContent.length} items with ${model}... (up to ${expectedTime} seconds)`;
                
                this.showLoadingOverlay(title, message, steps);

                const button = $('#evaluate-btn');
                const originalText = button.html();
                button.prop('disabled', true);

                try {
                    console.log('[Evaluation] Starting evaluation with:', {
                        mode: evalMode,
                        itemCount: evaluationContent.length,
                        model: model,
                        area: this.currentArea
                    });
                    
                    this.updateLoadingStep('prepare', 'active');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    this.updateLoadingStep('prepare', 'completed');
                    this.updateLoadingStep('send', 'active', `Sending ${evaluationContent.length} items to server...`);
                    
                    const endpoint = evalMode === 'agent' 
                        ? '/api/flows/admin/chat/evaluate/agent' 
                        : '/api/flows/admin/chat/evaluate';
                    
                    console.log('[Evaluation] Using endpoint:', endpoint);
                    
                    // Add dynamic timeout based on number of items (3 seconds per item, minimum 30 seconds)
                    const timeoutMs = Math.max(30000, evaluationContent.length * 3000);
                    console.log(`[Evaluation] Setting timeout to ${timeoutMs}ms for ${evaluationContent.length} items`);
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                    
                    let response;
                    try {
                        response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                area: this.currentArea,
                                content: evaluationContent,
                                prompt: prompt,
                                model: model,
                                useRules: true,
                                useCorrections: true,
                                areaFilters: this.areaFilters // Include available filters for the AI to choose from
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                    } catch (fetchError) {
                        clearTimeout(timeoutId);
                        console.error('[Evaluation] Fetch error:', fetchError);
                        if (fetchError.name === 'AbortError') {
                            const timeoutSeconds = Math.round(timeoutMs / 1000);
                            throw new Error(`Request timed out after ${timeoutSeconds} seconds. The server is taking too long to respond. Try evaluating fewer items at once.`);
                        }
                        throw fetchError;
                    }
                    
                    console.log('[Evaluation] Request sent successfully');

                    this.updateLoadingStep('send', 'completed');
                    
                    if (evalMode === 'agent') {
                        this.updateLoadingStep('rules', 'active', 'Applying high-confidence rules...');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        this.updateLoadingStep('rules', 'completed');
                        
                        this.updateLoadingStep('corrections', 'active', 'Checking learned patterns...');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        this.updateLoadingStep('corrections', 'completed');
                    }
                    
                    this.updateLoadingStep('process', 'active', 'AI is analyzing content...');

                    // Check if response is OK before parsing
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Server error: ${response.status} - ${errorText}`);
                    }

                    let data;
                    try {
                        data = await response.json();
                    } catch (parseError) {
                        throw new Error('Failed to parse server response. The response may be invalid.');
                    }
                    
                    if (data.success) {
                        this.updateLoadingStep('process', 'completed', `Evaluated ${data.totalEvaluated} items`);
                        this.updateLoadingStep('apply', 'active', 'Updating form fields...');
                        
                        this.currentEvaluation = data;
                        await this.applyEvaluationResults(data);
                        
                        this.updateLoadingStep('apply', 'completed');
                        this.updateLoadingStep('complete', 'completed', 'Evaluation complete!');
                        
                        // Show completion for a moment
                        await new Promise(resolve => setTimeout(resolve, 800));
                        this.hideLoadingOverlay();
                        
                        this.showEvaluationSummary(data);
                        
                        if (!isAutoRetry) {
                            this.addChatMessage('assistant', data.message);
                        }
                        
                        // Check if we need to retry for unevaluated items
                        const unevaluatedItems = this.getUnevaluatedItems();
                        if (unevaluatedItems.length > 0 && data.totalEvaluated > 0) {
                            // Automatically retry with unevaluated items
                            this.addChatMessage('system', `Found ${unevaluatedItems.length} unevaluated items. Automatically re-evaluating...`);
                            
                            // Use setTimeout to allow UI to update
                            setTimeout(() => {
                                this.evaluateContent(unevaluatedItems, true);
                            }, 1000);
                        } else {
                            // All items evaluated or no more evaluations returned
                            if (isAutoRetry && data.totalEvaluated === 0) {
                                this.addChatMessage('system', 'Could not evaluate remaining items. Please try adjusting your prompt or model.');
                            } else {
                                this.addChatMessage('system', 'All items have been evaluated successfully!');
                            }
                            
                            // Clear selected items after evaluation
                            this.selectedForEvaluation = null;
                        }
                        
                        // Show chat interface
                        $('#chat-messages').show();
                        $('#chat-input-area').show();
                    } else {
                        this.hideLoadingOverlay();
                        alert('Evaluation failed: ' + data.message);
                    }
                } catch (error) {
                    console.error('Evaluation failed:', error);
                    this.hideLoadingOverlay();
                    alert('Evaluation failed: ' + error.message);
                } finally {
                    button.html(originalText);
                    button.prop('disabled', false);
                }
            }

            getUnevaluatedItems() {
                const unevaluatedItems = [];
                
                this.contentData.forEach(item => {
                    const labels = this.labels.get(item.id);
                    if (!labels || !labels.scope) {
                        unevaluatedItems.push(item);
                    }
                });
                
                return unevaluatedItems;
            }

            async evaluateContentInBatches(allContent, batchSize = 15) {
                const totalItems = allContent.length;
                const totalBatches = Math.ceil(totalItems / batchSize);
                const prompt = $('#prompt-textarea').val();
                const model = $('#model-select').val();
                const evalMode = $('input[name="eval-mode"]:checked').val();
                
                // Instead of modal, show inline progress
                const progressHtml = `
                    <div id="batch-progress" style="background: #e0f2fe; border: 1px solid #0284c7; border-radius: 8px; padding: 12px; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>Batch Evaluation Progress</strong>
                                <div id="batch-status" style="font-size: 14px; color: #0c4a6e; margin-top: 4px;">
                                    Starting evaluation of ${totalItems} items in ${totalBatches} batches...
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div id="batch-count" style="font-size: 24px; font-weight: bold; color: #0284c7;">0/${totalBatches}</div>
                                <div style="font-size: 12px; color: #64748b;">Batches Complete</div>
                            </div>
                        </div>
                        <div style="margin-top: 8px; background: white; border-radius: 4px; overflow: hidden; height: 8px;">
                            <div id="batch-progress-bar" style="height: 100%; background: #0284c7; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                `;
                
                // Add progress to the chat area
                $('#evaluation-summary').before(progressHtml);
                
                // Show chat interface immediately
                $('#chat-messages').show();
                $('#chat-input-area').show();

                const button = $('#evaluate-btn');
                const originalText = button.html();
                button.html('<span class="loading-spinner"></span>Processing...');
                button.prop('disabled', true);

                // Initialize aggregated results
                const aggregatedResults = {
                    success: true,
                    message: '',
                    ratings: [],
                    totalEvaluated: 0,
                    rulesApplied: 0,
                    correctionsUsed: 0,
                    summary: {
                        local: 0,
                        national: 0,
                        hyperlocal: 0,
                        averageQuality: 0,
                        averageRelevance: 0,
                        trendingCount: 0
                    },
                    evaluationDetails: {}
                };

                try {
                    // Process batches
                    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                        const start = batchIndex * batchSize;
                        const end = Math.min(start + batchSize, totalItems);
                        const batchContent = allContent.slice(start, end);
                        
                        // Update inline progress
                        $('#batch-status').text(`Evaluating items ${start + 1}-${end} of ${totalItems}...`);
                        
                        try {
                            // Evaluate current batch
                            const endpoint = evalMode === 'agent' 
                                ? '/api/flows/admin/chat/evaluate/agent' 
                                : '/api/flows/admin/chat/evaluate';
                            
                            const response = await fetch(endpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    area: this.currentArea,
                                    content: batchContent,
                                    prompt: prompt,
                                    model: model,
                                    useRules: true,
                                    useCorrections: true,
                                    areaFilters: this.areaFilters
                                })
                            });

                            if (!response.ok) {
                                throw new Error(`Server error: ${response.status}`);
                            }

                            const batchResult = await response.json();
                            
                            if (batchResult.success) {
                                // Aggregate results
                                aggregatedResults.ratings.push(...batchResult.ratings);
                                aggregatedResults.totalEvaluated += batchResult.totalEvaluated;
                                aggregatedResults.rulesApplied += (batchResult.rulesApplied || 0);
                                aggregatedResults.correctionsUsed += (batchResult.correctionsUsed || 0);
                                
                                // Merge evaluation details
                                if (batchResult.evaluationDetails) {
                                    Object.assign(aggregatedResults.evaluationDetails, batchResult.evaluationDetails);
                                }
                                
                                // Apply batch results to UI immediately
                                await this.applyEvaluationResults(batchResult);
                                
                                // Update progress
                                const progress = ((batchIndex + 1) / totalBatches) * 100;
                                $('#batch-progress-bar').css('width', `${progress}%`);
                                $('#batch-count').html(`${batchIndex + 1}/${totalBatches}`);
                                
                                // Show batch completion message
                                this.addChatMessage('system', 
                                    `‚úì Batch ${batchIndex + 1}/${totalBatches} complete: Evaluated ${batchResult.totalEvaluated} items`
                                );
                            } else {
                                console.error(`Batch ${batchIndex + 1} failed:`, batchResult.message);
                                this.addChatMessage('system', 
                                    `‚ö†Ô∏è Batch ${batchIndex + 1} failed: ${batchResult.message}`
                                );
                            }
                            
                        } catch (batchError) {
                            console.error(`Error in batch ${batchIndex + 1}:`, batchError);
                            this.addChatMessage('system', 
                                `‚ùå Error in batch ${batchIndex + 1}: ${batchError.message}`
                            );
                        }
                        
                        // Add a small delay between batches to avoid overwhelming the server
                        if (batchIndex < totalBatches - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                    
                    // Calculate final summary
                    if (aggregatedResults.ratings.length > 0) {
                        const summary = this.calculateSummary(aggregatedResults.ratings);
                        aggregatedResults.summary = summary;
                        aggregatedResults.message = `Successfully evaluated ${aggregatedResults.totalEvaluated} out of ${totalItems} items in ${totalBatches} batches`;
                    }
                    
                    // Update progress to complete
                    $('#batch-status').html('<strong style="color: #059669;">‚úì Evaluation Complete!</strong>');
                    $('#batch-progress-bar').css('background', '#059669');
                    
                    // Show final summary
                    this.currentEvaluation = aggregatedResults;
                    this.showEvaluationSummary(aggregatedResults);
                    
                    // Show completion message
                    this.addChatMessage('assistant', aggregatedResults.message);
                    
                    // Check for unevaluated items
                    const unevaluatedItems = this.getUnevaluatedItems();
                    if (unevaluatedItems.length > 0) {
                        this.addChatMessage('system', 
                            `Found ${unevaluatedItems.length} items that could not be evaluated. You may try again with a different prompt or model.`
                        );
                    } else {
                        this.addChatMessage('system', 'üéâ All items have been evaluated successfully!');
                    }
                    
                    // Clear selected items
                    this.selectedForEvaluation = null;
                    
                    // Remove progress after 5 seconds
                    setTimeout(() => {
                        $('#batch-progress').fadeOut(500, function() {
                            $(this).remove();
                        });
                    }, 5000);
                    
                } catch (error) {
                    console.error('Batch evaluation failed:', error);
                    $('#batch-status').html('<strong style="color: #dc2626;">‚úó Evaluation Failed</strong>');
                    $('#batch-progress-bar').css('background', '#dc2626');
                    this.addChatMessage('system', `‚ùå Evaluation failed: ${error.message}`);
                    
                    // Remove progress after 5 seconds
                    setTimeout(() => {
                        $('#batch-progress').fadeOut(500, function() {
                            $(this).remove();
                        });
                    }, 5000);
                } finally {
                    button.html(originalText);
                    button.prop('disabled', false);
                }
            }

            calculateSummary(ratings) {
                if (!ratings || ratings.length === 0) {
                    return {
                        local: 0,
                        national: 0,
                        hyperlocal: 0,
                        averageQuality: 0,
                        averageRelevance: 0,
                        trendingCount: 0
                    };
                }

                const summary = {
                    local: 0,
                    national: 0,
                    hyperlocal: 0,
                    averageQuality: 0,
                    averageRelevance: 0,
                    trendingCount: 0
                };

                let totalQuality = 0;
                let totalRelevance = 0;

                ratings.forEach(rating => {
                    // Count scopes
                    if (rating.scope === 'local') summary.local++;
                    else if (rating.scope === 'national') summary.national++;
                    else if (rating.scope === 'hyperlocal') summary.hyperlocal++;
                    
                    // Sum quality and relevance
                    totalQuality += rating.quality || 0;
                    totalRelevance += rating.relevance || 0;
                    
                    // Count trending
                    if (rating.trending) summary.trendingCount++;
                });

                // Calculate averages
                summary.averageQuality = Math.round((totalQuality / ratings.length) * 10) / 10;
                summary.averageRelevance = Math.round((totalRelevance / ratings.length) * 10) / 10;

                return summary;
            }

            applyEvaluationResults(evaluation) {
                const ratingsMap = new Map();
                evaluation.ratings.forEach(rating => {
                    ratingsMap.set(rating.contentId, rating);
                });

                // Update labels in memory - only for items that were evaluated
                evaluation.ratings.forEach(rating => {
                    // If we have selectedForEvaluation, only update those items
                    if (!this.selectedForEvaluation || this.selectedForEvaluation.includes(rating.contentId)) {
                        // Store original evaluation if not already stored
                        if (!this.originalEvaluations.has(rating.contentId)) {
                            this.originalEvaluations.set(rating.contentId, {
                                scope: rating.scope,
                                quality: rating.quality,
                                relevance: rating.relevance,
                                trending: rating.trending,
                                filters: rating.filters || [],
                                reasoning: rating.reasoning
                            });
                        }
                        
                        const labelData = {
                            scope: rating.scope,
                            quality: rating.quality,
                            relevance: rating.relevance,
                            trending: rating.trending,
                            reasoning: rating.reasoning
                        };
                        
                        // Only add filters to labels if they exist
                        if (rating.filters && rating.filters.length > 0) {
                            labelData.filters = rating.filters;
                        }
                        
                        this.labels.set(rating.contentId, labelData);
                    }
                });

                // Update UI elements in the DataTable
                if (this.table) {
                    const tableApi = this.table;
                    const selectedItems = this.selectedForEvaluation;
                    const self = this; // Store reference to ContentLabelingTable instance
                    
                    // Iterate through table rows and update inputs
                    tableApi.rows().every(function() {
                        const rowData = this.data();
                        const item = rowData[11]; // Item data is stored in column 11 (updated due to filters column)
                        const rating = ratingsMap.get(item.id);
                        
                        // Only update if item was evaluated AND (no selection OR item is in selection)
                        if (rating && (!selectedItems || selectedItems.includes(item.id))) {
                            const rowNode = this.node();
                            
                            // Update scope select
                            $(rowNode).find(`.scope-select[data-id="${item.id}"]`).val(rating.scope);
                            
                            // Update quality input
                            $(rowNode).find(`.quality-input[data-id="${item.id}"]`).val(rating.quality);
                            
                            // Update relevance input
                            $(rowNode).find(`.relevance-input[data-id="${item.id}"]`).val(rating.relevance);
                            
                            // Update trending checkbox
                            $(rowNode).find(`.trending-checkbox[data-id="${item.id}"]`).prop('checked', rating.trending);
                            
                            // Update filter selections if provided
                            if (rating.filters && Array.isArray(rating.filters)) {
                                // Update our internal tracking
                                self.updateFilters(item.id, rating.filters);
                                
                                // Update the UI - remove all selected classes first
                                $(rowNode).find(`.filter-chip`).removeClass('selected');
                                
                                // Add selected class to chosen filters
                                rating.filters.forEach(filterId => {
                                    $(rowNode).find(`.filter-chip[data-filter-id="${filterId}"]`).addClass('selected');
                                });
                            }
                            
                            // Add reasoning indicator if available
                            if (rating.reasoning) {
                                // Remove any existing reasoning indicator
                                $(rowNode).find('.reasoning-indicator').remove();
                                $(rowNode).find('.teach-button').remove();
                                
                                // Add a subtle info icon with reasoning tooltip
                                const reasoningHtml = `<span class="reasoning-indicator" title="${rating.reasoning.replace(/"/g, '&quot;')}" style="cursor: help; margin-left: 5px; color: #6b7280; font-size: 12px;">‚ìò</span>`;
                                
                                // Add teaching button for corrections
                                const teachHtml = `<button class="teach-button" data-id="${item.id}" style="margin-left: 5px; padding: 2px 6px; font-size: 11px; background: #fbbf24; color: #78350f; border: none; border-radius: 3px; cursor: pointer;" title="Teach why you made this correction">üéì</button>`;
                                
                                // Add them after the title cell
                                const titleCell = $(rowNode).find('td:nth-child(3) > div');
                                titleCell.append(reasoningHtml);
                                titleCell.append(teachHtml);
                            }
                        }
                    });
                }

                this.updateStats();
            }

            showEvaluationSummary(evaluation) {
                const summary = evaluation.summary;
                
                let message = evaluation.message;
                // Add agent-specific information if available
                if (evaluation.rulesApplied !== undefined) {
                    message += ` (${evaluation.rulesApplied} rules applied, ${evaluation.correctionsUsed} corrections used)`;
                }
                
                $('#summary-message').text(message);
                $('#summary-local').text(summary.local);
                $('#summary-national').text(summary.national);
                $('#summary-hyperlocal').text(summary.hyperlocal);
                $('#summary-quality').text(summary.averageQuality);
                $('#summary-relevance').text(summary.averageRelevance);
                $('#summary-trending').text(summary.trendingCount);
                
                // Add sample reasonings
                const reasoningSamples = $('#reasoning-samples');
                reasoningSamples.empty();
                
                // Get up to 5 sample reasonings
                const sampleRatings = evaluation.ratings.slice(0, 5);
                sampleRatings.forEach(rating => {
                    const item = this.contentData.find(c => c.id === rating.contentId);
                    if (item && rating.reasoning) {
                        const reasoningHtml = `
                            <div style="margin-bottom: 10px; padding: 8px; background: #f9fafb; border-radius: 4px;">
                                <strong style="color: #1f2937;">${item.title.substring(0, 50)}${item.title.length > 50 ? '...' : ''}</strong>
                                <div style="margin-top: 4px;">
                                    <span style="color: #059669;">Scope: ${rating.scope}</span> | 
                                    <span style="color: #3b82f6;">Quality: ${rating.quality}/10</span> | 
                                    <span style="color: #8b5cf6;">Relevance: ${rating.relevance}/10</span>
                                    ${rating.trending ? ' | <span style="color: #ef4444;">üî• Trending</span>' : ''}
                                </div>
                                <div style="margin-top: 4px; font-style: italic;">"${rating.reasoning}"</div>
                            </div>
                        `;
                        reasoningSamples.append(reasoningHtml);
                    }
                });
                
                if (sampleRatings.length === 0 || !sampleRatings.some(r => r.reasoning)) {
                    reasoningSamples.append('<p style="color: #9ca3af;">No reasoning available for this evaluation.</p>');
                }
                
                $('#evaluation-summary').show();
            }

            async evaluateSelectedContent(message, model) {
                // Filter content to only selected items
                const selectedContent = this.contentData.filter(item => 
                    this.selectedForEvaluation.includes(item.id)
                );

                if (selectedContent.length === 0) {
                    this.addChatMessage('assistant', 'No items were selected for evaluation.');
                    this.selectedForEvaluation = null;
                    return;
                }

                // Show loading
                const loadingId = this.addChatMessage('assistant', '<span class="loading-spinner"></span>Evaluating selected items...');

                try {
                    const response = await fetch('/api/flows/admin/chat/evaluate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            area: this.currentArea,
                            content: selectedContent,
                            prompt: message,
                            model: model
                        })
                    });

                    const data = await response.json();
                    
                    // Remove loading message
                    $(`#${loadingId}`).remove();
                    
                    if (data.success) {
                        this.currentEvaluation = data;
                        this.applyEvaluationResults(data);
                        this.showEvaluationSummary(data);
                        this.addChatMessage('assistant', `Successfully evaluated ${data.totalEvaluated} selected items. ${data.message}`);
                        
                        // Clear selected items after evaluation
                        this.selectedForEvaluation = null;
                    } else {
                        this.addChatMessage('assistant', 'Evaluation failed: ' + data.message);
                    }
                } catch (error) {
                    console.error('Evaluation failed:', error);
                    $(`#${loadingId}`).remove();
                    this.addChatMessage('assistant', 'Failed to evaluate selected items.');
                } finally {
                    // Clear selection
                    this.selectedForEvaluation = null;
                }
            }

            async sendChatMessage() {
                const input = $('#chat-input');
                const message = input.val().trim();
                
                if (!message || !this.currentArea || this.contentData.length === 0) {
                    return;
                }

                input.val('');
                const model = $('#model-select').val();

                // Add user message to chat
                this.addChatMessage('user', message);

                // Check if this is an evaluation request for specific items
                const evaluateMatch = message.match(/Please evaluate these (\d+) selected items:/);
                if (evaluateMatch && this.selectedForEvaluation) {
                    // This is an evaluation request for selected items
                    await this.evaluateSelectedContent(message, model);
                    return;
                }

                // Show loading
                const loadingId = this.addChatMessage('assistant', '<span class="loading-spinner"></span>Thinking...');

                try {
                    const response = await fetch('/api/flows/admin/chat/message', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            area: this.currentArea,
                            content: this.contentData,
                            message: message,
                            model: model,
                            conversationHistory: this.conversationHistory
                        })
                    });

                    const data = await response.json();
                    
                    // Remove loading message
                    $(`#${loadingId}`).remove();

                    if (data.success) {
                        this.addChatMessage('assistant', data.response);
                        
                        // Update conversation history
                        this.conversationHistory.push(
                            { role: 'user', content: message },
                            { role: 'assistant', content: data.response }
                        );
                    } else {
                        this.addChatMessage('assistant', 'Sorry, I encountered an error: ' + data.message);
                    }
                } catch (error) {
                    console.error('Chat failed:', error);
                    $(`#${loadingId}`).remove();
                    this.addChatMessage('assistant', 'Sorry, I encountered an error processing your message.');
                }
            }

            addChatMessage(role, content) {
                const messagesContainer = $('#chat-messages');
                const messageId = 'msg-' + Date.now();
                const messageDiv = $(`
                    <div id="${messageId}" class="chat-message ${role}">
                        <div class="role">${role === 'user' ? 'You' : 'Assistant'}</div>
                        <div>${content}</div>
                    </div>
                `);
                
                messagesContainer.append(messageDiv);
                messagesContainer.scrollTop(messagesContainer[0].scrollHeight);
                
                return messageId;
            }
        }

        // Initialize on page load
        $(document).ready(() => {
            new ContentLabelingTable();
        });
    </script>
</body>
</html>